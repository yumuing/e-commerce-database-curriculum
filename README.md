# e-commerce-database-curriculum
这是一次简单的数据库应用设计，从用户商家注册到商品信息的查询，上下架，最后到订单的整体运行流程设计，比较简陋。

目录

[索引... 2](#_Toc91353996)

[被频繁使用的字段设置索引... 2](#_Toc91353997)

[逻辑非常重要的sql 设计索引... 2](#_Toc91353998)

[视图... 2](#_Toc91353999)

[用户视图：... 2](#_Toc91354000)

[商家视图：... 3](#_Toc91354001)

[存储过程... 3](#_Toc91354002)

[存储过程-订单... 3](#_Toc91354003)

[存储过程-订单信息更新... 4](#_Toc91354004)

[存储过程-商品上下架... 5](#_Toc91354005)

[存储过程-地址增删改查... 6](#_Toc91354006)

[存储过程——用户注册... 6](#_Toc91354007)

[存储过程——商家注册... 6](#_Toc91354008)

[触发器... 7](#_Toc91354009)

[演示设计：... 8](#_Toc91354010)

[用户... 8](#_Toc91354011)

[商家... 8](#_Toc91354012)

[订单... 8](#_Toc91354013)

 

## 索引

 

### 被频繁使用的字段设置索引

字段被频繁用在where 和order 等条件里面

数据表创建完毕，要预估那些字段被经常使用，就给其创建索引

给商品属性PRODUCTPROPERTIES表的

商品编号ProductId列建立一个名为ProductId-INDEXT的唯一值方式建立索引

给商家信息COMPANY表的商家编号CompanyId列建立一个名为

CompanyId-INDEXT的唯一值方式建立索引

给订单信息ORDERINFORMATION表的订单编号OrderId列建立一个名为OrderId-INDEXT的唯一值方式建立索引

给仓库信息WAREHOUSEINFO表的仓库编号WarehouseID列建立一个名为WarehouseID-INDEXT的唯一值方式建立索引

给收货地址SHIPPINGADDRESS表的地址编号AddressId列建立一个名为AddressId-INDEXT的唯一值方式建立索引

 

### 逻辑非常重要的sql 设计索引

例如商城系统里面，用户的登陆ID比较重要。

还有用户下订单购物，订单的状态也比较重要。

给登陆注册USERS表的用户id-UserId列上建立一个名为id-UserId-INDEXT的唯一值方式建立索引

给订单状态OrderStatus表的订单编号OrderId列建立一个名OrderId-INDEXT的唯一值方式建立索引

## 视图

### 用户视图：

用户可查看到自己权限范围内的信息，每个用户都有自己独立的两个信息视图，用户视图分两个：

一是用户个人信息

(用户id、用户名、密码、手机号、注册时间、地址编号、收货地址)，

二是用户全部订单信息

（用户id、订单编号、下单时间、支付方式、商家编号、商品编号、商品金额、购买数量、总金额、快递单号、发货时间、收货时间、运费、物流状态码）。

 

### 商家视图：

商家可查看到自己权限范围内的信息，每个商家都有自己独立的三个信息视图，商家视图分三个：

一是商家个人信息

（商家编号、商家名称、商家描述、仓库编号、仓库租用到期时间、仓库 地址）；

二是商家全部订单信息

（商家编号、订单编号、收货人、地址编号、用户手机、用户id、订单状态码）；

三是商家商品信息

（商家编号、商品编号、商品数量、上架时间）。

## 存储过程

### 存储过程-订单

 

1. 订单查询

输入参数：订单编号

输出参数：集合（包含订单编号，订单状态，下单时间，总金额）

声明临时变量： @订单状态，@下单时间，@总金额，@商品id，@商品金额，@商品数量，

定义游标，设为，根据订单编号查询订单信息表

创建一个Ｔ－临时表（视图），存放用户的订单编号，订单状态，下单时间，商品id，商品金额，商品数量，总金额

将订单编号所对应的订单编号，订单状态，下单时间，商品id，商品金额，商品数量，总金额插入到临时表中

显示临时表中对应订单编号的元组内容

 

作用：用户可以根据订单编号查询订单的订单状态，下单时间，商品id，商品金额，商品数量，总金额信息

 

2. 订单创建

传入参数：用户id，下单时间，商品编号，商品金额，总金额，购买数量

输出参数：订单编号

判断如果购买数量大于仓库的商品数量，print（‘仓库库存不足，请及时补充’），更新仓库商品数量，在原有基础+购买数量

订单编号=订单编号表中最后订单编号+1

商品金额=商品价格*购买数量

总金额=商品金额+运费

运用insert语句将信息插入订单信息E表中。

添加订单编号到订单状态G表中，订单状态码初始状态是0.订单创建（未支付）

快递单号初始状态为空

触发器执行

 

作用

用户传输数据到订单信息表中，提交订单， 数据库根据信息更新相关的表数据。

 

 

 

3. 订单删除

传入参数：订单编号

输出参数：null

声明临时变量：@用户id，@下单时间，@支付方式，@商品编号，@商品金额，@总金额，@购买数量

触发器停止

查询订单状态G表

订单状态码  0：订单创建;1:订单已支付；2：订单已完成          

如果订单状态码==0时

根据订单编号级联删除订单状态G表和订单信息E表相关元组。

如果订单状态码==1时

1. 通过订单编号访问订单信息E表，获取数据。

2. 根据商品编号更新仓库信息表，回滚到订单未创建时的仓库商品数量。

3. 根据快递单号在物流F表删除相关元组。

4. 根据用户id和订单编号删除收货信息H的相关元组

5. 根据订单编号级联删除订单状态G表和订单信息E表相关元组

如果订单状态码==2时

Print（交易已完成，无法删除）

作用

用户取消自己的订单，数据库根据订单编号删除规定范围内的数据

 

 

### 存储过程-订单信息更新

 

1. 用户购买信息更新



输入参数： @OrderId 订单编号，@Payment 支付方式状态码

（0：微信支付；1：支付宝支付；2：银行卡支付；3.未支付）

输出参数：无

 

若支付方式状态码为 3，则

更新订单信息表 ORDERINFORMATION

依据订单编号更新支付方式

触发器执行

Print 购买成功

否则退出存储过程

 

2. 商家物流信息更新 (商家发货)



输入参数： @OrderId 订单编号

输出参数：无

 

创建临时变量@LogisticsStatusCode 物流状态码 = 0 （出库）

更新物流表中的物流状态码为 0 

 

创建收货信息表 receiveinfo

获取插入订单编号 OrderId

获取插入用户id UserId 

插入地址编号 AddressId 用户手机 UserPhone 收货人 Consignee

Print 商品已发货

 

3. 用户确认收货



输入参数: @OrderId 订单编号

输出参数：无

 

创建临时变量@LogisticsStatusCode 物流状态码 = 2 （已收货）

更新物流表中的物流状态码为 2 

Print 商品已签收

 

### 存储过程-商品上下架

 

1. 商品上架

输入参数：，商品名称，规格参数，品牌，价格

输出参数： 无

临时变量：@id 商品编号@ name商品名称，@param规格参数，@brand 品牌， @price 价格

生成商品编号（自增），（若商品编号重复 print 商品重复）

将参数赋予临时变量中，用临时变量将数据插入商品属性表(PRODUCTPROPERTIES)中。

将商品信息更新到商家-商品关系表 COMPANYRODUCTREL 中

Print 商品上架成功

 

2. 商品下架

输入参数：商品编号

输出参数：无

根据商品编号删除多个表信息（商家-商品关系表、商品属性表、仓库信息表）

，若数据库中无此商品编号，

Print 数据库中无此商品

 

 

### 存储过程-地址增删改查

1. 增加收货地址：

输入参数：收货人，地址编号，省名，市名，区名，详细地址、用户编号

输出参数：无

生成收货地址编号

增加输入的数据（收货人，地址编号，用户编号，省名，市名，区名，详细地址）

 

2. 删除收货地址：

输入参数：地址编号、用户编号

输出参数：无

查找收货地址表中是否包含该地址编号和用户编号的联合主码元组，若有则执行删除并返回“地址编号已删除”，若没有则返回“输入的地址编号不存在”

 

3. 更改收货地址：、用户编号

输入参数：收货人，地址编号，省名，市名，区名，详细地址

输出参数：无

查找收货地址表中是否包含该地址编号和用户编号的联合主码元组，若有则执行更改并返回“地址编号已更改”，若没有则返回“输入的地址编号不存在”

 

4. 查找收货地址：

输入参数：地址编号、用户编号

输出参数：收货人，地址编号，省名，市名，区名，详细地址

查找收货地址表中是否包含该地址编号和用户编号的联合主码元组，若有则执行查找并返回“地址编号已查找到如下：”，若没有则返回“输入的地址编号不存在”

### 存储过程——用户注册

输入参数：@用户编号 @用户名 @用户密码 @注册时间 @手机号 

输出参数：无

增加用户登录\注册一组元组（@用户编号=用户编号自增 @用户名 @用户密码）

@注册时间=当前执行时间

增加用户信息（@用户编号 @注册时间 @手机号）

新建用户信息视图、用户全部订单视图

 

### 存储过程——商家注册

输入参数：@商家名称 @商家描述

输出参数：无

增加商家信息表的一组元组（商家编号自增 @商家名称 @商家描述）

新建商家信息视图、商家全部订单视图、商家商品视图

 

 

触发器

1. 触发器—监视订单信息表行级插入

更新订单状态表 ORDERSTATUS

创建临时变量 @OrderId 订单编号，@OrderStatusCode 订单状态码

接收存储过程创建的订单编号 @OrderId 写入表中

Print 订单已创建

 

2. 触发器—当订单状态码更新且状态码为1时执行

（0：订单创建;1:订单已支付；2：订单已完成）

 

更新物流表 LOGISTICS 

创建并插入快递单号 ExpressNumber（自增）

获取当前时间 插入发货时间 DeliveryTime

插入运费 @Freight（以随机数模拟）

Print 物流表已创建

 

3. 触发器—当物流状态码更新时

(0：出库 ；1：配送中；2：已收货；3：未出库)

--状态码为0时执行 {

更新物流表 LOGISTICS

更新物流状态码为 1 

Print 订单配送中

 

以订单编号获取订单信息

将购买数量存入临时变量 @Quantity

将商品编号存入临时变量 @ProductId

 

更新商品属性表

商品销量ProductSales 增加 @Quantity 个

Print 商品销量已更新

 

更新仓库信息表

商品编号为 @ProductId 的商品数量减 @Quantity 个 

Print 仓库商品数量已更新

 }

 

--状态码为2时执行 {

更新订单状态表

将订单状态码更新为2

Pirnt 商品已确认收货

 

更新物流表

获取当前时间到临时变量 @ReceiptTime 中

更新 @ReceiptTime 到收货时间 ReceiptTime

}

## 演示设计：

## 用户

1. 调用用户注册存储过程，新增用户
2. 调用收货地址增加存储过程
3. 调用收货地址修改存储过程
4. 调用收货地址查询存储过程
5. 调用收货地址删除存储过程
6. 调用收货地址增加存储过程（保证存在收货地址）

## 商家

1. 调用商家注册存储过程
2. 调用商品上架存储过程
3. 调用商品下架存储过程
4. 调用商品上架存储过程（保证存在商品）

## 订单

1. 触发器正常执行——订单正常流程

    - 调用订单创建存储过程，即商品购买
    - 触发触发器更新订单状态、物流状态
    - 调用存储过程用户购买信息更新
    - 触发触发器更新订单状态
    - 调用存储过程商家物流信息更新 (商家发货)
    - 触发触发器更新物流状态
    - 调用存储过程用户确认收货
    - 触发触发器更新物流状态，订单完成

2. 触发器被中止——订单删除

    - 调用订单创建存储过程，即商品购买
    - 触发触发器更新订单状态、物流状态
    - 调用订单删除存储过程（测试订单状态码==0）
    - 调用订单创建存储过程，即商品购买
    - 触发触发器更新订单状态、物流状态
    - 调用存储过程用户购买信息更新
    - 调用订单删除存储过程（测试订单状态码==1）
    - 调用订单创建存储过程，即商品购买
    - 触发触发器更新订单状态、物流状态
    - 调用存储过程商家物流信息更新 (商家发货)
    - 触发触发器更新物流状态
    - 调用存储过程用户确认收货
    - 调用订单删除存储过程（测试订单状态码==2）

3. 订单查询——搜索订单
4. 
    - 调用订单创建存储过程，即商品购买

    - 触发触发器更新订单状态、物流状态

    - 调用订单查询功能查询该订单

 

 

 

 

 

 
